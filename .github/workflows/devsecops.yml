name: DevSecOps Security + Deployment Pipeline

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
  pull_request:
    branches: [ main ]

jobs:
  security-and-deploy:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout Code
      - name: Checkout Code
        uses: actions/checkout@v4

      # 2. Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3. Build Docker Image
      - name: Build Docker Image
        run: docker build -t awsassignment-app:secure .

      # 4. Verify Docker Image Exists
      - name: Verify Docker Image Exists
        run: docker images awsassignment-app:secure

      # 5. Install Trivy
      - name: Install Trivy
        run: |
          sudo apt-get update
          sudo apt-get install wget -y
          wget https://github.com/aquasecurity/trivy/releases/download/v0.52.2/trivy_0.52.2_Linux-64bit.deb
          sudo dpkg -i trivy_0.52.2_Linux-64bit.deb
          trivy --version

      # 6. Run Trivy Image Scan
      - name: Run Trivy Image Scan
        run: |
          trivy image --format table --output trivy-secure-report.txt --ignore-unfixed --exit-code 0 --severity HIGH,CRITICAL awsassignment-app:secure

      # 7. Upload Trivy Report
      - name: Upload Trivy Report
        uses: actions/upload-artifact@v4
        with:
          name: trivy-secure-report
          path: trivy-secure-report.txt

      # 8. Snyk Scan
      - name: Run Snyk Scan
        uses: snyk/actions/docker@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: awsassignment-app:secure

      # 9. Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # 10. Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.8

      # ðŸ§¹ NEW STEP â€“ Auto Cleanup Old Cluster if Exists
      - name: Auto Cleanup Old EKS Resources
        continue-on-error: true
        run: |
          echo "ðŸ§¹ Checking for old EKS cluster and node groups..."
          CLUSTER_NAME="secure-eks-cluster"
          if aws eks describe-cluster --name $CLUSTER_NAME --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
            echo "EKS cluster exists. Deleting node groups first..."
            NODEGROUPS=$(aws eks list-nodegroups --cluster-name $CLUSTER_NAME --region ${{ secrets.AWS_REGION }} --query 'nodegroups' --output text)
            for ng in $NODEGROUPS; do
              echo "Deleting node group: $ng"
              aws eks delete-nodegroup --cluster-name $CLUSTER_NAME --nodegroup-name $ng --region ${{ secrets.AWS_REGION }}
              aws eks wait nodegroup-deleted --cluster-name $CLUSTER_NAME --nodegroup-name $ng --region ${{ secrets.AWS_REGION }}
            done
            echo "Deleting cluster..."
            aws eks delete-cluster --name $CLUSTER_NAME --region ${{ secrets.AWS_REGION }}
            aws eks wait cluster-deleted --name $CLUSTER_NAME --region ${{ secrets.AWS_REGION }}
          else
            echo "No existing EKS cluster found. Continuing..."
          fi

      # ðŸ§¹ NEW STEP â€“ Auto Cleanup IAM Roles if Exist
      - name: Auto Cleanup IAM Roles
        continue-on-error: true
        run: |
          echo "ðŸ§¹ Checking for existing IAM roles..."
          for role in secure-eks-cluster-role secure-eks-cluster-node-role; do
            if aws iam get-role --role-name $role >/dev/null 2>&1; then
              echo "Detaching policies and deleting $role..."
              POLICY_ARNS=$(aws iam list-attached-role-policies --role-name $role --query 'AttachedPolicies[*].PolicyArn' --output text)
              for arn in $POLICY_ARNS; do
                aws iam detach-role-policy --role-name $role --policy-arn $arn || true
              done
              aws iam delete-role --role-name $role || true
            else
              echo "Role $role not found."
            fi
          done

      # 11. Terraform Init
      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init
      - name: Import Existing ECR Repository
        working-directory: ./terraform
        run: terraform import module.ecr.aws_ecr_repository.app_repository awsassignment-app || true
      - name: Import Existing VPC & Subnets
        working-directory: ./terraform
        run: terraform import module.vpc.aws_vpc.this vpc-055290eca3d5ff33c || true
             terraform import 'module.vpc.aws_subnet.public[2]' subnet-0b688080d039a9c41 || true
             
            

      # 12. Terraform Plan
      - name: Terraform Plan
        working-directory: ./terraform
        run: terraform plan

      # 13. Terraform Apply
      - name: Terraform Apply
        working-directory: ./terraform
        run: terraform apply -auto-approve

      # 14. Login to Amazon ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # 15. Push Docker Image to ECR
      - name: Build, Tag, and Push to ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: awsassignment-app
          IMAGE_TAG: latest
        run: |
          docker tag awsassignment-app:secure $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG

      # 16. Update kubeconfig
      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name secure-eks-cluster

      # 17. Deploy to EKS
      - name: Deploy to EKS
        run: |
          kubectl apply -f k8s/deployment-mongo.yaml
          kubectl apply -f k8s/service-mongo.yaml
          kubectl apply -f k8s/deployment-app.yaml
          kubectl apply -f k8s/service-app.yaml
          kubectl apply -f k8s/ingress.yaml

      # 18. Verify Deployment
      - name: Verify Kubernetes Resources
        run: |
          kubectl get pods
          kubectl get svc
          kubectl get ingress
